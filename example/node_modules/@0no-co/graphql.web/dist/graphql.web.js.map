{"version":3,"file":"graphql.web.js","sources":["../src/error.ts","../src/parser.ts","../src/visitor.ts","../src/printer.ts","../src/values.ts","../src/kind.js"],"sourcesContent":["import { Maybe, Extensions, Source } from './types';\nimport { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString() {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n}\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport { Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nconst nameRe = /[_\\w][_\\d\\w]*/y;\nfunction name(): ast.NameNode | undefined {\n  let match: string | undefined;\n  if ((match = advance(nameRe))) {\n    return {\n      kind: 'Name' as Kind.NAME,\n      value: match,\n    };\n  }\n}\n\nconst constRe = /null|true|false/y;\nconst variableRe = /\\$[_\\w][_\\d\\w]*/y;\nconst intRe = /-?\\d+/y;\nconst floatPartRe = /(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/y;\nconst complexStringRe = /\\\\/g;\nconst blockStringRe = /\"\"\"(?:[\\s\\S]+(?=\"\"\"))?\"\"\"/y;\nconst stringRe = /\"(?:[^\"\\r\\n]+)?\"/y;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode | undefined {\n  let out: ast.ValueNode | undefined;\n  let match: string | undefined;\n  if ((match = advance(constRe))) {\n    out =\n      match === 'null'\n        ? {\n            kind: 'NullValue' as Kind.NULL,\n          }\n        : {\n            kind: 'BooleanValue' as Kind.BOOLEAN,\n            value: match === 'true',\n          };\n  } else if (!constant && (match = advance(variableRe))) {\n    out = {\n      kind: 'Variable' as Kind.VARIABLE,\n      name: {\n        kind: 'Name' as Kind.NAME,\n        value: match.slice(1),\n      },\n    };\n  } else if ((match = advance(intRe))) {\n    const intPart = match;\n    if ((match = advance(floatPartRe))) {\n      out = {\n        kind: 'FloatValue' as Kind.FLOAT,\n        value: intPart + match,\n      };\n    } else {\n      out = {\n        kind: 'IntValue' as Kind.INT,\n        value: intPart,\n      };\n    }\n  } else if ((match = advance(nameRe))) {\n    out = {\n      kind: 'EnumValue' as Kind.ENUM,\n      value: match,\n    };\n  } else if ((match = advance(blockStringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: blockString(match.slice(3, -3)),\n      block: true,\n    };\n  } else if ((match = advance(stringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: complexStringRe.test(match) ? (JSON.parse(match) as string) : match.slice(1, -1),\n      block: false,\n    };\n  } else if ((out = list(constant) || object(constant))) {\n    return out;\n  }\n\n  ignored();\n  return out;\n}\n\nfunction list(constant: boolean): ast.ListValueNode | undefined {\n  let match: ast.ValueNode | undefined;\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const values: ast.ValueNode[] = [];\n    while ((match = value(constant))) values.push(match);\n    if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListValue');\n    ignored();\n    return {\n      kind: 'ListValue' as Kind.LIST,\n      values,\n    };\n  }\n}\n\nfunction object(constant: boolean): ast.ObjectValueNode | undefined {\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const fields: ast.ObjectFieldNode[] = [];\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField' as Kind.OBJECT_FIELD);\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('ObjectField');\n      fields.push({\n        kind: 'ObjectField' as Kind.OBJECT_FIELD,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('ObjectValue');\n    ignored();\n    return {\n      kind: 'ObjectValue' as Kind.OBJECT,\n      fields,\n    };\n  }\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] {\n  const args: ast.ArgumentNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('Argument');\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (!args.length || input.charCodeAt(idx++) !== 41 /*')'*/) throw error('Argument');\n    ignored();\n  }\n  return args;\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[];\nfunction directives(constant: boolean): ast.DirectiveNode[];\n\nfunction directives(constant: boolean): ast.DirectiveNode[] {\n  const directives: ast.DirectiveNode[] = [];\n  ignored();\n  while (input.charCodeAt(idx) === 64 /*'@'*/) {\n    idx++;\n    const _name = name();\n    if (!_name) throw error('Directive');\n    ignored();\n    directives.push({\n      kind: 'Directive' as Kind.DIRECTIVE,\n      name: _name,\n      arguments: arguments_(constant),\n    });\n  }\n  return directives;\n}\n\nfunction field(): ast.FieldNode | undefined {\n  let _name = name();\n  if (_name) {\n    ignored();\n    let _alias: ast.NameNode | undefined;\n    if (input.charCodeAt(idx) === 58 /*':'*/) {\n      idx++;\n      ignored();\n      _alias = _name;\n      _name = name();\n      if (!_name) throw error('Field');\n      ignored();\n    }\n    return {\n      kind: 'Field' as Kind.FIELD,\n      alias: _alias,\n      name: _name,\n      arguments: arguments_(false),\n      directives: directives(false),\n      selectionSet: selectionSet(),\n    };\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let match: ast.NameNode | ast.TypeNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const _type = type();\n    if (!_type || input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListType');\n    match = {\n      kind: 'ListType' as Kind.LIST_TYPE,\n      type: _type,\n    };\n  } else if ((match = name())) {\n    match = {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: match,\n    };\n  } else {\n    throw error('NamedType');\n  }\n\n  ignored();\n  if (input.charCodeAt(idx) === 33 /*'!'*/) {\n    idx++;\n    ignored();\n    return {\n      kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n      type: match,\n    };\n  } else {\n    return match;\n  }\n}\n\nconst typeConditionRe = /on/y;\nfunction typeCondition(): ast.NamedTypeNode | undefined {\n  if (advance(typeConditionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('NamedType');\n    ignored();\n    return {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: _name,\n    };\n  }\n}\n\nconst fragmentSpreadRe = /\\.\\.\\./y;\n\nfunction fragmentSpread(): ast.FragmentSpreadNode | ast.InlineFragmentNode | undefined {\n  if (advance(fragmentSpreadRe)) {\n    ignored();\n    const _idx = idx;\n    let _name: ast.NameNode | undefined;\n    if ((_name = name()) && _name.value !== 'on') {\n      return {\n        kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n        name: _name,\n        directives: directives(false),\n      };\n    } else {\n      idx = _idx;\n      const _typeCondition = typeCondition();\n      const _directives = directives(false);\n      const _selectionSet = selectionSet();\n      if (!_selectionSet) throw error('InlineFragment');\n      return {\n        kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n        typeCondition: _typeCondition,\n        directives: _directives,\n        selectionSet: _selectionSet,\n      };\n    }\n  }\n}\n\nfunction selectionSet(): ast.SelectionSetNode | undefined {\n  let match: ast.SelectionNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const selections: ast.SelectionNode[] = [];\n    while ((match = fragmentSpread() || field())) selections.push(match);\n    if (!selections.length || input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('SelectionSet');\n    ignored();\n    return {\n      kind: 'SelectionSet' as Kind.SELECTION_SET,\n      selections,\n    };\n  }\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] {\n  let match: string | undefined;\n  const vars: ast.VariableDefinitionNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    while ((match = advance(variableRe))) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      const _type = type();\n      let _defaultValue: ast.ValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n        if (!_defaultValue) throw error('VariableDefinition');\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: {\n            kind: 'Name' as Kind.NAME,\n            value: match.slice(1),\n          },\n        },\n        type: _type,\n        defaultValue: _defaultValue as ast.ConstValueNode,\n        directives: directives(true),\n      });\n    }\n    if (input.charCodeAt(idx++) !== 41 /*')'*/) throw error('VariableDefinition');\n    ignored();\n  }\n  return vars;\n}\n\nconst fragmentDefinitionRe = /fragment/y;\nfunction fragmentDefinition(): ast.FragmentDefinitionNode | undefined {\n  if (advance(fragmentDefinitionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('FragmentDefinition');\n    ignored();\n    const _typeCondition = typeCondition();\n    if (!_typeCondition) throw error('FragmentDefinition');\n    const _directives = directives(false);\n    const _selectionSet = selectionSet();\n    if (!_selectionSet) throw error('FragmentDefinition');\n    return {\n      kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n      name: _name,\n      typeCondition: _typeCondition,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\nconst operationDefinitionRe = /query|mutation|subscription/y;\nfunction operationDefinition(): ast.OperationDefinitionNode | undefined {\n  let _operation: string | undefined;\n  let _name: ast.NameNode | undefined;\n  let _variableDefinitions: ast.VariableDefinitionNode[] = [];\n  let _directives: ast.DirectiveNode[] = [];\n  if ((_operation = advance(operationDefinitionRe))) {\n    ignored();\n    _name = name();\n    _variableDefinitions = variableDefinitions();\n    _directives = directives(false);\n  }\n  const _selectionSet = selectionSet();\n  if (_selectionSet) {\n    return {\n      kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n      operation: (_operation || 'query') as OperationTypeNode,\n      name: _name,\n      variableDefinitions: _variableDefinitions,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\nfunction document(): ast.DocumentNode {\n  let match: ast.ExecutableDefinitionNode | void;\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  while ((match = fragmentDefinition() || operationDefinition())) definitions.push(match);\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return document();\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  ignored();\n  const _value = value(false);\n  if (!_value) throw error('ValueNode');\n  return _value;\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n  ? ReadonlyArray<R>\n  : R;\n","import { ASTNode } from './ast';\n\nexport function printString(string: string) {\n  return JSON.stringify(string);\n}\n\nexport function printBlockString(string: string) {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst hasItems = <T>(array: ReadonlyArray<T> | undefined | null): array is ReadonlyArray<T> =>\n  !!(array && array.length);\n\nconst MAX_LINE_LENGTH = 80;\n\nconst nodes: {\n  [NodeT in ASTNode as NodeT['kind']]?: (node: NodeT) => string;\n} = {\n  OperationDefinition(node) {\n    if (\n      node.operation === 'query' &&\n      !node.name &&\n      !hasItems(node.variableDefinitions) &&\n      !hasItems(node.directives)\n    ) {\n      return nodes.SelectionSet!(node.selectionSet);\n    }\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (hasItems(node.variableDefinitions)) {\n      if (!node.name) out += ' ';\n      out += '(' + node.variableDefinitions.map(nodes.VariableDefinition!).join(', ') + ')';\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + nodes.SelectionSet!(node.selectionSet);\n  },\n  VariableDefinition(node) {\n    let out = nodes.Variable!(node.variable) + ': ' + print(node.type);\n    if (node.defaultValue) out += ' = ' + print(node.defaultValue);\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  Field(node) {\n    let out = (node.alias ? node.alias.value + ': ' : '') + node.name.value;\n    if (hasItems(node.arguments)) {\n      const args = node.arguments.map(nodes.Argument!);\n      const argsLine = out + '(' + args.join(', ') + ')';\n      out =\n        argsLine.length > MAX_LINE_LENGTH\n          ? out + '(\\n  ' + args.join('\\n').replace(/\\n/g, '\\n  ') + '\\n)'\n          : argsLine;\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return node.selectionSet ? out + ' ' + nodes.SelectionSet!(node.selectionSet) : out;\n  },\n  StringValue(node) {\n    return node.block ? printBlockString(node.value) : printString(node.value);\n  },\n  BooleanValue(node) {\n    return '' + node.value;\n  },\n  NullValue(_node) {\n    return 'null';\n  },\n  IntValue(node) {\n    return node.value;\n  },\n  FloatValue(node) {\n    return node.value;\n  },\n  EnumValue(node) {\n    return node.value;\n  },\n  Name(node) {\n    return node.value;\n  },\n  Variable(node) {\n    return '$' + node.name.value;\n  },\n  ListValue(node) {\n    return '[' + node.values.map(print).join(', ') + ']';\n  },\n  ObjectValue(node) {\n    return '{' + node.fields.map(nodes.ObjectField!).join(', ') + '}';\n  },\n  ObjectField(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  Document(node) {\n    return hasItems(node.definitions) ? node.definitions.map(print).join('\\n\\n') : '';\n  },\n  SelectionSet(node) {\n    return '{\\n  ' + node.selections.map(print).join('\\n').replace(/\\n/g, '\\n  ') + '\\n}';\n  },\n  Argument(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  FragmentSpread(node) {\n    let out = '...' + node.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  InlineFragment(node) {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  FragmentDefinition(node) {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  Directive(node) {\n    let out = '@' + node.name.value;\n    if (hasItems(node.arguments)) out += '(' + node.arguments.map(nodes.Argument!).join(', ') + ')';\n    return out;\n  },\n  NamedType(node) {\n    return node.name.value;\n  },\n  ListType(node) {\n    return '[' + print(node.type) + ']';\n  },\n  NonNullType(node) {\n    return print(node.type) + '!';\n  },\n};\n\nexport function print(node: ASTNode): string {\n  return nodes[node.kind] ? (nodes as any)[node.kind]!(node) : '';\n}\n","import { TypeNode, ValueNode } from './ast';\nimport { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (const value of node.values) values.push(valueFromASTUntyped(value, variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (const field of node.fields)\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (const value of node.values) {\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n","export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n"],"names":["GraphQLError","Error","constructor","message","nodes","source","positions","path","originalError","extensions","super","this","name","Array","isArray","let","_extensions","const","originalExtensions","toJSON","toString","toStringTag","Symbol","input","idx","error","kind","advance","pattern","lastIndex","test","slice","leadingRe","blockString","string","lines","split","out","commonIndent","firstNonEmptyLine","lastNonEmptyLine","length","i","replace","ignored","char","charCodeAt","nameRe","match","value","constRe","variableRe","intRe","floatPartRe","complexStringRe","blockStringRe","stringRe","constant","intPart","block","JSON","parse","list","values","push","object","fields","_name","_value","arguments_","args","directives","arguments","field","_alias","alias","selectionSet","type","_type","typeConditionRe","typeCondition","fragmentSpreadRe","fragmentSpread","_idx","_typeCondition","_directives","_selectionSet","selections","fragmentDefinitionRe","fragmentDefinition","operationDefinitionRe","operationDefinition","_operation","_variableDefinitions","variableDefinitions","vars","_defaultValue","variable","defaultValue","operation","BREAK","printString","stringify","printBlockString","hasItems","array","OperationDefinition","node","SelectionSet","map","VariableDefinition","join","Directive","Variable","print","Field","Argument","argsLine","StringValue","BooleanValue","NullValue","_node","IntValue","FloatValue","EnumValue","Name","ListValue","ObjectValue","ObjectField","Document","definitions","FragmentSpread","InlineFragment","FragmentDefinition","NamedType","ListType","NonNullType","valueFromASTUntyped","variables","parseInt","parseFloat","obj","Object","create","i$1","list$1","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","QUERY","MUTATION","SUBSCRIPTION","_options","body","document","parseType","parseValue","valueFromTypeNode","undefined","coerced","visit","visitor","ancestors","result","traverse","key","parent","hasEdited","enter","resultEnter","call","copy","nodeKey","newValue","index","pop","leave","resultLeave"],"mappings":"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"}