{"version":3,"names":["lerp","value","from","to","p1","p2","t","interpolate","interpolatePaths","input","outputRange","options","extrapolation","validateInterpolationOptions","extrapolateLeft","Extrapolate","CLAMP","EXTEND","IDENTITY","Error","exhaustiveCheck","length","extrapolateRight","i"],"sources":["interpolatePaths.ts"],"sourcesContent":["import type { SkPath } from \"../../skia/types\";\nimport { exhaustiveCheck } from \"../../renderer/typeddash\";\n\nimport type { ExtrapolationType } from \"./interpolate\";\nimport { validateInterpolationOptions, Extrapolate } from \"./interpolate\";\n\nconst lerp = (\n  value: number,\n  from: number,\n  to: number,\n  p1: SkPath,\n  p2: SkPath\n) => {\n  const t = (value - from) / (to - from);\n  return p2.interpolate(p1, t)!;\n};\n\n/**\n * Maps an input value within a range to an output path within a path range.\n * @param value - The input value.\n * @param inputRange - The range of the input value.\n * @param outputRange - The range of the output path.\n * @param options - Extrapolation options\n * @returns The output path.\n * @example <caption>Map a value between 0 and 1 to a path between two paths.</caption>\n * const path1 = new Path();\n * path1.moveTo(0, 0);\n * path1.lineTo(100, 0);\n * const path2 = new Path();\n * path2.moveTo(0, 0);\n * path2.lineTo(0, 100);\n * const path = interpolatePath(0.5, [0, 1], [path1, path2]);\n */\nexport const interpolatePaths = (\n  value: number,\n  input: number[],\n  outputRange: SkPath[],\n  options?: ExtrapolationType\n) => {\n  const extrapolation = validateInterpolationOptions(options);\n  if (value < input[0]) {\n    switch (extrapolation.extrapolateLeft) {\n      case Extrapolate.CLAMP:\n        return outputRange[0];\n      case Extrapolate.EXTEND:\n        return lerp(value, input[0], input[1], outputRange[0], outputRange[1]);\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateLeft);\n    }\n  } else if (value > input[input.length - 1]) {\n    switch (extrapolation.extrapolateRight) {\n      case Extrapolate.CLAMP:\n        return outputRange[outputRange.length - 1];\n      case Extrapolate.EXTEND:\n        return lerp(\n          value,\n          input[input.length - 2],\n          input[input.length - 1],\n          outputRange[input.length - 2],\n          outputRange[input.length - 1]\n        );\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateRight);\n    }\n  }\n  let i = 0;\n  for (; i <= input.length - 1; i++) {\n    if (value >= input[i] && value <= input[i + 1]) {\n      break;\n    }\n  }\n  return lerp(\n    value,\n    input[i],\n    input[i + 1],\n    outputRange[i],\n    outputRange[i + 1]\n  );\n};\n"],"mappings":";;;;;;;AACA;;AAGA;;AAEA,MAAMA,IAAI,GAAG,CACXC,KADW,EAEXC,IAFW,EAGXC,EAHW,EAIXC,EAJW,EAKXC,EALW,KAMR;EACH,MAAMC,CAAC,GAAG,CAACL,KAAK,GAAGC,IAAT,KAAkBC,EAAE,GAAGD,IAAvB,CAAV;EACA,OAAOG,EAAE,CAACE,WAAH,CAAeH,EAAf,EAAmBE,CAAnB,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAME,gBAAgB,GAAG,CAC9BP,KAD8B,EAE9BQ,KAF8B,EAG9BC,WAH8B,EAI9BC,OAJ8B,KAK3B;EACH,MAAMC,aAAa,GAAG,IAAAC,yCAAA,EAA6BF,OAA7B,CAAtB;;EACA,IAAIV,KAAK,GAAGQ,KAAK,CAAC,CAAD,CAAjB,EAAsB;IACpB,QAAQG,aAAa,CAACE,eAAtB;MACE,KAAKC,wBAAA,CAAYC,KAAjB;QACE,OAAON,WAAW,CAAC,CAAD,CAAlB;;MACF,KAAKK,wBAAA,CAAYE,MAAjB;QACE,OAAOjB,IAAI,CAACC,KAAD,EAAQQ,KAAK,CAAC,CAAD,CAAb,EAAkBA,KAAK,CAAC,CAAD,CAAvB,EAA4BC,WAAW,CAAC,CAAD,CAAvC,EAA4CA,WAAW,CAAC,CAAD,CAAvD,CAAX;;MACF,KAAKK,wBAAA,CAAYG,QAAjB;QACE,MAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;MAGF;QACE,IAAAC,0BAAA,EAAgBR,aAAa,CAACE,eAA9B;IAVJ;EAYD,CAbD,MAaO,IAAIb,KAAK,GAAGQ,KAAK,CAACA,KAAK,CAACY,MAAN,GAAe,CAAhB,CAAjB,EAAqC;IAC1C,QAAQT,aAAa,CAACU,gBAAtB;MACE,KAAKP,wBAAA,CAAYC,KAAjB;QACE,OAAON,WAAW,CAACA,WAAW,CAACW,MAAZ,GAAqB,CAAtB,CAAlB;;MACF,KAAKN,wBAAA,CAAYE,MAAjB;QACE,OAAOjB,IAAI,CACTC,KADS,EAETQ,KAAK,CAACA,KAAK,CAACY,MAAN,GAAe,CAAhB,CAFI,EAGTZ,KAAK,CAACA,KAAK,CAACY,MAAN,GAAe,CAAhB,CAHI,EAITX,WAAW,CAACD,KAAK,CAACY,MAAN,GAAe,CAAhB,CAJF,EAKTX,WAAW,CAACD,KAAK,CAACY,MAAN,GAAe,CAAhB,CALF,CAAX;;MAOF,KAAKN,wBAAA,CAAYG,QAAjB;QACE,MAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;MAGF;QACE,IAAAC,0BAAA,EAAgBR,aAAa,CAACU,gBAA9B;IAhBJ;EAkBD;;EACD,IAAIC,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,IAAId,KAAK,CAACY,MAAN,GAAe,CAA3B,EAA8BE,CAAC,EAA/B,EAAmC;IACjC,IAAItB,KAAK,IAAIQ,KAAK,CAACc,CAAD,CAAd,IAAqBtB,KAAK,IAAIQ,KAAK,CAACc,CAAC,GAAG,CAAL,CAAvC,EAAgD;MAC9C;IACD;EACF;;EACD,OAAOvB,IAAI,CACTC,KADS,EAETQ,KAAK,CAACc,CAAD,CAFI,EAGTd,KAAK,CAACc,CAAC,GAAG,CAAL,CAHI,EAITb,WAAW,CAACa,CAAD,CAJF,EAKTb,WAAW,CAACa,CAAC,GAAG,CAAL,CALF,CAAX;AAOD,CArDM"}