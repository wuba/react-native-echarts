{"version":3,"names":["exhaustiveCheck","validateInterpolationOptions","Extrapolate","lerp","value","from","to","p1","p2","t","interpolate","interpolatePaths","input","outputRange","options","extrapolation","extrapolateLeft","CLAMP","EXTEND","IDENTITY","Error","length","extrapolateRight","i"],"sources":["interpolatePaths.ts"],"sourcesContent":["import type { SkPath } from \"../../skia/types\";\nimport { exhaustiveCheck } from \"../../renderer/typeddash\";\n\nimport type { ExtrapolationType } from \"./interpolate\";\nimport { validateInterpolationOptions, Extrapolate } from \"./interpolate\";\n\nconst lerp = (\n  value: number,\n  from: number,\n  to: number,\n  p1: SkPath,\n  p2: SkPath\n) => {\n  const t = (value - from) / (to - from);\n  return p2.interpolate(p1, t)!;\n};\n\n/**\n * Maps an input value within a range to an output path within a path range.\n * @param value - The input value.\n * @param inputRange - The range of the input value.\n * @param outputRange - The range of the output path.\n * @param options - Extrapolation options\n * @returns The output path.\n * @example <caption>Map a value between 0 and 1 to a path between two paths.</caption>\n * const path1 = new Path();\n * path1.moveTo(0, 0);\n * path1.lineTo(100, 0);\n * const path2 = new Path();\n * path2.moveTo(0, 0);\n * path2.lineTo(0, 100);\n * const path = interpolatePath(0.5, [0, 1], [path1, path2]);\n */\nexport const interpolatePaths = (\n  value: number,\n  input: number[],\n  outputRange: SkPath[],\n  options?: ExtrapolationType\n) => {\n  const extrapolation = validateInterpolationOptions(options);\n  if (value < input[0]) {\n    switch (extrapolation.extrapolateLeft) {\n      case Extrapolate.CLAMP:\n        return outputRange[0];\n      case Extrapolate.EXTEND:\n        return lerp(value, input[0], input[1], outputRange[0], outputRange[1]);\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateLeft);\n    }\n  } else if (value > input[input.length - 1]) {\n    switch (extrapolation.extrapolateRight) {\n      case Extrapolate.CLAMP:\n        return outputRange[outputRange.length - 1];\n      case Extrapolate.EXTEND:\n        return lerp(\n          value,\n          input[input.length - 2],\n          input[input.length - 1],\n          outputRange[input.length - 2],\n          outputRange[input.length - 1]\n        );\n      case Extrapolate.IDENTITY:\n        throw new Error(\n          \"Identity is not a supported extrapolation type for interpolatePaths()\"\n        );\n      default:\n        exhaustiveCheck(extrapolation.extrapolateRight);\n    }\n  }\n  let i = 0;\n  for (; i <= input.length - 1; i++) {\n    if (value >= input[i] && value <= input[i + 1]) {\n      break;\n    }\n  }\n  return lerp(\n    value,\n    input[i],\n    input[i + 1],\n    outputRange[i],\n    outputRange[i + 1]\n  );\n};\n"],"mappings":"AACA,SAASA,eAAT,QAAgC,0BAAhC;AAGA,SAASC,4BAAT,EAAuCC,WAAvC,QAA0D,eAA1D;;AAEA,MAAMC,IAAI,GAAG,CACXC,KADW,EAEXC,IAFW,EAGXC,EAHW,EAIXC,EAJW,EAKXC,EALW,KAMR;EACH,MAAMC,CAAC,GAAG,CAACL,KAAK,GAAGC,IAAT,KAAkBC,EAAE,GAAGD,IAAvB,CAAV;EACA,OAAOG,EAAE,CAACE,WAAH,CAAeH,EAAf,EAAmBE,CAAnB,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,gBAAgB,GAAG,CAC9BP,KAD8B,EAE9BQ,KAF8B,EAG9BC,WAH8B,EAI9BC,OAJ8B,KAK3B;EACH,MAAMC,aAAa,GAAGd,4BAA4B,CAACa,OAAD,CAAlD;;EACA,IAAIV,KAAK,GAAGQ,KAAK,CAAC,CAAD,CAAjB,EAAsB;IACpB,QAAQG,aAAa,CAACC,eAAtB;MACE,KAAKd,WAAW,CAACe,KAAjB;QACE,OAAOJ,WAAW,CAAC,CAAD,CAAlB;;MACF,KAAKX,WAAW,CAACgB,MAAjB;QACE,OAAOf,IAAI,CAACC,KAAD,EAAQQ,KAAK,CAAC,CAAD,CAAb,EAAkBA,KAAK,CAAC,CAAD,CAAvB,EAA4BC,WAAW,CAAC,CAAD,CAAvC,EAA4CA,WAAW,CAAC,CAAD,CAAvD,CAAX;;MACF,KAAKX,WAAW,CAACiB,QAAjB;QACE,MAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;MAGF;QACEpB,eAAe,CAACe,aAAa,CAACC,eAAf,CAAf;IAVJ;EAYD,CAbD,MAaO,IAAIZ,KAAK,GAAGQ,KAAK,CAACA,KAAK,CAACS,MAAN,GAAe,CAAhB,CAAjB,EAAqC;IAC1C,QAAQN,aAAa,CAACO,gBAAtB;MACE,KAAKpB,WAAW,CAACe,KAAjB;QACE,OAAOJ,WAAW,CAACA,WAAW,CAACQ,MAAZ,GAAqB,CAAtB,CAAlB;;MACF,KAAKnB,WAAW,CAACgB,MAAjB;QACE,OAAOf,IAAI,CACTC,KADS,EAETQ,KAAK,CAACA,KAAK,CAACS,MAAN,GAAe,CAAhB,CAFI,EAGTT,KAAK,CAACA,KAAK,CAACS,MAAN,GAAe,CAAhB,CAHI,EAITR,WAAW,CAACD,KAAK,CAACS,MAAN,GAAe,CAAhB,CAJF,EAKTR,WAAW,CAACD,KAAK,CAACS,MAAN,GAAe,CAAhB,CALF,CAAX;;MAOF,KAAKnB,WAAW,CAACiB,QAAjB;QACE,MAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;;MAGF;QACEpB,eAAe,CAACe,aAAa,CAACO,gBAAf,CAAf;IAhBJ;EAkBD;;EACD,IAAIC,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,IAAIX,KAAK,CAACS,MAAN,GAAe,CAA3B,EAA8BE,CAAC,EAA/B,EAAmC;IACjC,IAAInB,KAAK,IAAIQ,KAAK,CAACW,CAAD,CAAd,IAAqBnB,KAAK,IAAIQ,KAAK,CAACW,CAAC,GAAG,CAAL,CAAvC,EAAgD;MAC9C;IACD;EACF;;EACD,OAAOpB,IAAI,CACTC,KADS,EAETQ,KAAK,CAACW,CAAD,CAFI,EAGTX,KAAK,CAACW,CAAC,GAAG,CAAL,CAHI,EAITV,WAAW,CAACU,CAAD,CAJF,EAKTV,WAAW,CAACU,CAAC,GAAG,CAAL,CALF,CAAX;AAOD,CArDM"}