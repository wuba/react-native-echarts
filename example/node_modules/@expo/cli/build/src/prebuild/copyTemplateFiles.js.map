{"version":3,"sources":["../../../src/prebuild/copyTemplateFiles.ts"],"sourcesContent":["import { PackageJSONConfig } from '@expo/config';\nimport { ModPlatform } from '@expo/config-plugins';\nimport { MergeResults } from '@expo/config-plugins/build/utils/generateCode';\nimport { getBareExtensions, getFileWithExtensions } from '@expo/config/paths';\nimport chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { copySync, directoryExistsAsync } from '../utils/dir';\nimport { mergeGitIgnorePaths } from '../utils/mergeGitIgnorePaths';\nimport { isPkgMainExpoAppEntry } from './updatePackageJson';\n\nconst debug = require('debug')('expo:prebuild:copyTemplateFiles') as typeof console.log;\n\ntype CopyFilesResults = {\n  /** Merge results for the root `.gitignore` file */\n  gitignore: MergeResults | null;\n  /** List of file paths that were copied from the template into the project. */\n  copiedPaths: string[];\n  /** List of file paths that were skipped due to a number of factors. */\n  skippedPaths: string[];\n};\n\n/**\n * Return true if the given platforms all have an internal `.gitignore` file.\n *\n * @param projectRoot\n * @param platforms\n */\nfunction hasAllPlatformSpecificGitIgnores(projectRoot: string, platforms: ModPlatform[]): boolean {\n  return platforms.reduce<boolean>(\n    (p, platform) => p && fs.existsSync(path.join(projectRoot, platform, '.gitignore')),\n    true\n  );\n}\n\n/** Create a custom log message based on the copy file results. */\nexport function createCopyFilesSuccessMessage(\n  platforms: ModPlatform[],\n  { skippedPaths, gitignore }: CopyFilesResults\n): string {\n  let message = `Created native project${platforms.length > 1 ? 's' : ''}`;\n\n  if (skippedPaths.length) {\n    message += chalk.dim(\n      ` | ${skippedPaths.map((path) => chalk.bold(`/${path}`)).join(', ')} already created`\n    );\n  }\n  if (!gitignore) {\n    message += chalk.dim(` | gitignore skipped`);\n  } else if (!gitignore.didMerge) {\n    message += chalk.dim(` | gitignore already synced`);\n  } else if (gitignore.didMerge && gitignore.didClear) {\n    message += chalk.dim(` | synced gitignore`);\n  }\n  return message;\n}\n\n/** Copy template files into the project and possibly merge the `.gitignore` files.  */\nexport async function copyTemplateFilesAsync(\n  projectRoot: string,\n  {\n    pkg,\n    templateDirectory,\n    platforms,\n  }: {\n    /** Project `package.json` as JSON. */\n    pkg: PackageJSONConfig;\n    /** File path to the template directory. */\n    templateDirectory: string;\n    /** List of platforms to copy against. */\n    platforms: ModPlatform[];\n  }\n): Promise<CopyFilesResults> {\n  const copyFilePaths = getFilePathsToCopy(projectRoot, pkg, platforms);\n\n  const copyResults = await copyPathsFromTemplateAsync(projectRoot, {\n    templateDirectory,\n    copyFilePaths,\n  });\n\n  const hasPlatformSpecificGitIgnores = hasAllPlatformSpecificGitIgnores(\n    templateDirectory,\n    platforms\n  );\n  debug(`All platforms have an internal gitignore: ${hasPlatformSpecificGitIgnores}`);\n  const gitignore = hasPlatformSpecificGitIgnores\n    ? null\n    : mergeGitIgnorePaths(\n        path.join(projectRoot, '.gitignore'),\n        path.join(templateDirectory, '.gitignore')\n      );\n\n  return { ...copyResults, gitignore };\n}\n\nasync function copyPathsFromTemplateAsync(\n  /** File path to the project. */\n  projectRoot: string,\n  {\n    templateDirectory,\n    copyFilePaths,\n  }: {\n    /** File path to the template project. */\n    templateDirectory: string;\n    /** List of relative paths to copy from the template to the project. */\n    copyFilePaths: string[];\n  }\n): Promise<Pick<CopyFilesResults, 'copiedPaths' | 'skippedPaths'>> {\n  const copiedPaths = [];\n  const skippedPaths = [];\n  for (const copyFilePath of copyFilePaths) {\n    const projectPath = path.join(projectRoot, copyFilePath);\n    if (!(await directoryExistsAsync(projectPath))) {\n      copiedPaths.push(copyFilePath);\n      copySync(path.join(templateDirectory, copyFilePath), projectPath);\n    } else {\n      skippedPaths.push(copyFilePath);\n    }\n  }\n  debug(`Copied files:`, copiedPaths);\n  debug(`Skipped files:`, copiedPaths);\n  return { copiedPaths, skippedPaths };\n}\n\n/** Get a list of relative file paths to copy from the template folder. Example: `['ios', 'android', 'index.js']` */\nfunction getFilePathsToCopy(projectRoot: string, pkg: PackageJSONConfig, platforms: ModPlatform[]) {\n  const targetPaths: string[] = [...platforms];\n\n  const bareEntryFile = resolveBareEntryFile(projectRoot, pkg.main);\n  // Only create index.js if we cannot resolve the existing entry point (after replacing the expo entry).\n  if (!bareEntryFile) {\n    targetPaths.push('index.js');\n  }\n\n  debug(`Files to copy:`, targetPaths);\n  return targetPaths;\n}\n\nexport function resolveBareEntryFile(projectRoot: string, main: any) {\n  // expo app entry is not needed for bare projects.\n  if (isPkgMainExpoAppEntry(main)) {\n    return null;\n  }\n  // Look at the `package.json`s `main` field for the main file.\n  const resolvedMainField = main ?? './index';\n  // Get a list of possible extensions for the main file.\n  const extensions = getBareExtensions(['ios', 'android']);\n  // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n  return getFileWithExtensions(projectRoot, resolvedMainField, extensions);\n}\n"],"names":["createCopyFilesSuccessMessage","copyTemplateFilesAsync","resolveBareEntryFile","debug","require","hasAllPlatformSpecificGitIgnores","projectRoot","platforms","reduce","p","platform","fs","existsSync","path","join","skippedPaths","gitignore","message","length","chalk","dim","map","bold","didMerge","didClear","pkg","templateDirectory","copyFilePaths","getFilePathsToCopy","copyResults","copyPathsFromTemplateAsync","hasPlatformSpecificGitIgnores","mergeGitIgnorePaths","copiedPaths","copyFilePath","projectPath","directoryExistsAsync","push","copySync","targetPaths","bareEntryFile","main","isPkgMainExpoAppEntry","resolvedMainField","extensions","getBareExtensions","getFileWithExtensions"],"mappings":"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"}