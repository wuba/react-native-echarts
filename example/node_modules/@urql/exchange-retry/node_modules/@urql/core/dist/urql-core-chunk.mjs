import { GraphQLError as r, print as e, parse as t, Kind as a } from "@0no-co/graphql.web";

import { filter as o, fromAsyncIterable as n } from "wonka";

var rehydrateGraphQlError = e => {
  if (e && e.message && (e.extensions || "GraphQLError" === e.name)) {
    return e;
  } else if ("object" == typeof e && e.message) {
    return new r(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});
  } else {
    return new r(e);
  }
};

class CombinedError extends Error {
  constructor(r) {
    var e = (r.graphQLErrors || []).map(rehydrateGraphQlError);
    var t = ((r, e) => {
      var t = "";
      if (r) {
        return `[Network] ${r.message}`;
      }
      if (e) {
        for (var a of e) {
          if (t) {
            t += "\n";
          }
          t += `[GraphQL] ${a.message}`;
        }
      }
      return t;
    })(r.networkError, e);
    super(t);
    this.name = "CombinedError";
    this.message = t;
    this.graphQLErrors = e;
    this.networkError = r.networkError;
    this.response = r.response;
  }
  toString() {
    return this.message;
  }
}

var phash = (r, e) => {
  var t = 0 | (e || 5381);
  for (var a = 0, o = 0 | r.length; a < o; a++) {
    t = (t << 5) + t + r.charCodeAt(a);
  }
  return t;
};

var s = new Set;

var i = new WeakMap;

var stringify = r => {
  if (null === r || s.has(r)) {
    return "null";
  } else if ("object" != typeof r) {
    return JSON.stringify(r) || "";
  } else if (r.toJSON) {
    return stringify(r.toJSON());
  } else if (Array.isArray(r)) {
    var e = "[";
    for (var t of r) {
      if (e.length > 1) {
        e += ",";
      }
      e += stringify(t) || "null";
    }
    return e += "]";
  } else if (f !== NoopConstructor && r instanceof f || l !== NoopConstructor && r instanceof l) {
    return "null";
  }
  var a = Object.keys(r).sort();
  if (!a.length && r.constructor && r.constructor !== Object) {
    var o = i.get(r) || Math.random().toString(36).slice(2);
    i.set(r, o);
    return stringify({
      __key: o
    });
  }
  s.add(r);
  var n = "{";
  for (var v of a) {
    var c = stringify(r[v]);
    if (c) {
      if (n.length > 1) {
        n += ",";
      }
      n += stringify(v) + ":" + c;
    }
  }
  s.delete(r);
  return n += "}";
};

var extract = (r, e, t) => {
  if (null == t || "object" != typeof t || t.toJSON || s.has(t)) {} else if (Array.isArray(t)) {
    for (var a = 0, o = t.length; a < o; a++) {
      extract(r, `${e}.${a}`, t[a]);
    }
  } else if (t instanceof f || t instanceof l) {
    r.set(e, t);
  } else {
    s.add(t);
    for (var n of Object.keys(t)) {
      extract(r, `${e}.${n}`, t[n]);
    }
  }
};

var stringifyVariables = r => {
  s.clear();
  return stringify(r);
};

class NoopConstructor {}

var f = "undefined" != typeof File ? File : NoopConstructor;

var l = "undefined" != typeof Blob ? Blob : NoopConstructor;

var v = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;

var c = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;

var replaceOutsideStrings = (r, e) => e % 2 == 0 ? r.replace(c, "\n") : r;

var sanitizeDocument = r => r.split(v).map(replaceOutsideStrings).join("").trim();

var d = new Map;

var p = new Map;

var stringifyDocument = r => {
  var t;
  if ("string" == typeof r) {
    t = sanitizeDocument(r);
  } else if (r.loc && p.get(r.__key) === r) {
    t = r.loc.source.body;
  } else {
    t = d.get(r) || sanitizeDocument(e(r));
    d.set(r, t);
  }
  if ("string" != typeof r && !r.loc) {
    r.loc = {
      start: 0,
      end: t.length,
      source: {
        body: t,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t;
};

var hashDocument = r => {
  var e = phash(stringifyDocument(r));
  if (r.definitions) {
    var t = getOperationName(r);
    if (t) {
      e = phash(`\n# ${t}`, e);
    }
  }
  return e;
};

var keyDocument = r => {
  var e;
  var a;
  if ("string" == typeof r) {
    e = hashDocument(r);
    a = p.get(e) || t(r, {
      noLocation: !0
    });
  } else {
    e = r.__key || hashDocument(r);
    a = p.get(e) || r;
  }
  if (!a.loc) {
    stringifyDocument(a);
  }
  a.__key = e;
  p.set(e, a);
  return a;
};

var createRequest = (r, e, t) => {
  var a = e || {};
  var o = keyDocument(r);
  var n = stringifyVariables(a);
  var s = o.__key;
  if ("{}" !== n) {
    s = phash(n, s);
  }
  return {
    key: s,
    query: o,
    variables: a,
    extensions: t
  };
};

var getOperationName = r => {
  for (var e of r.definitions) {
    if (e.kind === a.OPERATION_DEFINITION) {
      return e.name ? e.name.value : void 0;
    }
  }
};

var getOperationType = r => {
  for (var e of r.definitions) {
    if (e.kind === a.OPERATION_DEFINITION) {
      return e.operation;
    }
  }
};

var makeResult = (r, e, t) => {
  if (!("data" in e) && !("errors" in e)) {
    throw new Error("No Content");
  }
  var a = "subscription" === r.kind;
  return {
    operation: r,
    data: e.data,
    error: Array.isArray(e.errors) ? new CombinedError({
      graphQLErrors: e.errors,
      response: t
    }) : void 0,
    extensions: e.extensions ? {
      ...e.extensions
    } : void 0,
    hasNext: null == e.hasNext ? a : e.hasNext,
    stale: !1
  };
};

var deepMerge = (r, e) => {
  if ("object" == typeof r && null != r) {
    if (!r.constructor || r.constructor === Object || Array.isArray(r)) {
      r = Array.isArray(r) ? [ ...r ] : {
        ...r
      };
      for (var t of Object.keys(e)) {
        r[t] = deepMerge(r[t], e[t]);
      }
      return r;
    }
  }
  return e;
};

var mergeResultPatch = (r, e, t) => {
  var a = r.error ? r.error.graphQLErrors : [];
  var o = !!r.extensions || !!e.extensions;
  var n = {
    ...r.extensions,
    ...e.extensions
  };
  var s = e.incremental;
  if ("path" in e) {
    s = [ e ];
  }
  var i = {
    data: r.data
  };
  if (s) {
    for (var f of s) {
      if (Array.isArray(f.errors)) {
        a.push(...f.errors);
      }
      if (f.extensions) {
        Object.assign(n, f.extensions);
        o = !0;
      }
      var l = "data";
      var v = i;
      for (var c = 0, d = f.path.length; c < d; l = f.path[c++]) {
        v = v[l] = Array.isArray(v[l]) ? [ ...v[l] ] : {
          ...v[l]
        };
      }
      if (f.items) {
        var p = +l >= 0 ? l : 0;
        for (var u = 0, y = f.items.length; u < y; u++) {
          v[p + u] = deepMerge(v[p + u], f.items[u]);
        }
      } else if (void 0 !== f.data) {
        v[l] = deepMerge(v[l], f.data);
      }
    }
  } else {
    i.data = e.data || r.data;
    a = e.errors || a;
  }
  return {
    operation: r.operation,
    data: i.data,
    error: a.length ? new CombinedError({
      graphQLErrors: a,
      response: t
    }) : void 0,
    extensions: o ? n : void 0,
    hasNext: null != e.hasNext ? e.hasNext : r.hasNext,
    stale: !1
  };
};

var makeErrorResult = (r, e, t) => ({
  operation: r,
  data: void 0,
  error: new CombinedError({
    networkError: e,
    response: t
  }),
  extensions: void 0,
  hasNext: !1,
  stale: !1
});

function makeFetchBody(r) {
  return {
    query: r.extensions && r.extensions.persistedQuery && !r.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r.query),
    operationName: getOperationName(r.query),
    variables: r.variables || void 0,
    extensions: r.extensions
  };
}

var makeFetchURL = (r, e) => {
  var t = "query" === r.kind && r.context.preferGetMethod;
  if (!t || !e) {
    return r.context.url;
  }
  var a = new URL(r.context.url);
  for (var o in e) {
    var n = e[o];
    if (n) {
      a.searchParams.set(o, "object" == typeof n ? stringifyVariables(n) : n);
    }
  }
  var s = a.toString();
  if (s.length > 2047 && "force" !== t) {
    r.context.preferGetMethod = !1;
    return r.context.url;
  }
  return s;
};

var serializeBody = (r, e) => {
  if (e && !("query" === r.kind && !!r.context.preferGetMethod)) {
    var t = stringifyVariables(e);
    var a = (r => {
      var e = new Map;
      if (f !== NoopConstructor || l !== NoopConstructor) {
        s.clear();
        extract(e, "variables", r);
      }
      return e;
    })(e.variables);
    if (a.size) {
      var o = new FormData;
      o.append("operations", t);
      o.append("map", stringifyVariables({
        ...[ ...a.keys() ].map((r => [ r ]))
      }));
      var n = 0;
      for (var i of a.values()) {
        o.append("" + n++, i);
      }
      return o;
    }
    return t;
  }
};

var makeFetchOptions = (r, e) => {
  var t = {
    accept: "subscription" === r.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a = ("function" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};
  if (a.headers) {
    for (var o in a.headers) {
      t[o.toLowerCase()] = a.headers[o];
    }
  }
  var n = serializeBody(r, e);
  if ("string" == typeof n && !t["content-type"]) {
    t["content-type"] = "application/json";
  }
  return {
    ...a,
    method: n ? "POST" : "GET",
    body: n,
    headers: t
  };
};

var u = "undefined" != typeof TextDecoder ? new TextDecoder : null;

var y = /boundary="?([^=";]+)"?/i;

var h = /data: ?([^\n]+)/;

var toString = r => "Buffer" === r.constructor.name ? r.toString() : u.decode(r);

async function* streamBody(r) {
  if (r.body[Symbol.asyncIterator]) {
    for await (var e of r.body) {
      yield toString(e);
    }
  } else {
    var t = r.body.getReader();
    var a;
    try {
      while (!(a = await t.read()).done) {
        yield toString(a.value);
      }
    } finally {
      t.cancel();
    }
  }
}

async function* split(r, e) {
  var t = "";
  var a;
  for await (var o of r) {
    t += o;
    while ((a = t.indexOf(e)) > -1) {
      yield t.slice(0, a);
      t = t.slice(a + e.length);
    }
  }
}

async function* fetchOperation(r, e, t) {
  var a = !0;
  var o;
  var n = null;
  var s;
  try {
    if ("undefined" != typeof AbortController) {
      t.signal = (o = new AbortController).signal;
    }
    yield await Promise.resolve();
    var i = (s = await (r.context.fetch || fetch)(e, t)).headers.get("Content-Type") || "";
    var f;
    if (/multipart\/mixed/i.test(i)) {
      f = async function* parseMultipartMixed(r, e) {
        var t = r.match(y);
        var a = "--" + (t ? t[1] : "-");
        var o = !0;
        var n;
        for await (var s of split(streamBody(e), "\r\n" + a)) {
          if (o) {
            o = !1;
            var i = s.indexOf(a);
            if (i > -1) {
              s = s.slice(i + a.length);
            } else {
              continue;
            }
          }
          try {
            yield n = JSON.parse(s.slice(s.indexOf("\r\n\r\n") + 4));
          } catch (r) {
            if (!n) {
              throw r;
            }
          }
          if (n && !n.hasNext) {
            break;
          }
        }
        if (n && n.hasNext) {
          yield {
            hasNext: !1
          };
        }
      }(i, s);
    } else if (/text\/event-stream/i.test(i)) {
      f = async function* parseEventStream(r) {
        var e;
        for await (var t of split(streamBody(r), "\n\n")) {
          var a = t.match(h);
          if (a) {
            var o = a[1];
            try {
              yield e = JSON.parse(o);
            } catch (r) {
              if (!e) {
                throw r;
              }
            }
            if (e && !e.hasNext) {
              break;
            }
          }
        }
        if (e && e.hasNext) {
          yield {
            hasNext: !1
          };
        }
      }(s);
    } else if (!/text\//i.test(i)) {
      f = async function* parseJSON(r) {
        yield JSON.parse(await r.text());
      }(s);
    } else {
      throw new Error(await s.text());
    }
    for await (var l of f) {
      n = n ? mergeResultPatch(n, l, s) : makeResult(r, l, s);
      a = !1;
      yield n;
      a = !0;
    }
    if (!n) {
      yield n = makeResult(r, {}, s);
    }
  } catch (e) {
    if (!a) {
      throw e;
    }
    yield makeErrorResult(r, s && (s.status < 200 || s.status >= 300) && s.statusText ? new Error(s.statusText) : e, s);
  } finally {
    if (o) {
      o.abort();
    }
  }
}

function makeFetchSource(r, e, t) {
  return o((r => !!r))(n(fetchOperation(r, e, t)));
}

export { CombinedError as C, mergeResultPatch as a, makeResult as b, makeErrorResult as c, makeFetchURL as d, makeFetchOptions as e, makeFetchSource as f, getOperationType as g, createRequest as h, stringifyVariables as i, keyDocument as k, makeFetchBody as m, stringifyDocument as s };
//# sourceMappingURL=urql-core-chunk.mjs.map
